% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat_hclust.R
\name{stat_hclust}
\alias{stat_hclust}
\title{Hierarchical clustering for morphometric data}
\usage{
stat_hclust(
  data,
  formula = NULL,
  method = "ward.D2",
  dist_method = "euclidean",
  center = TRUE,
  scale = NULL,
  k = NULL,
  h = NULL,
  ...
)
}
\arguments{
\item{data}{A tibble with coefficient columns}

\item{formula}{A formula specifying predictors. Can be:
\itemize{
\item Missing: auto-detects single coe column
\item Bare column name: \code{coe}
\item Formula: \code{~ coe}, \code{~ coe + size}, \code{~ coe1 + coe2}
}}

\item{method}{Character. Agglomeration method for hierarchical clustering.
One of "ward.D2" (default), "single", "complete", "average", "mcquitty",
"median", "centroid". See \code{\link[stats:hclust]{stats::hclust()}}.}

\item{dist_method}{Character. Distance metric. Default is "euclidean".
Other options: "manhattan", "maximum", "canberra", "binary", "minkowski".
See \code{\link[stats:dist]{stats::dist()}}.}

\item{center}{Logical. Should data be centered? Default \code{TRUE}.}

\item{scale}{Logical or NULL. Should data be scaled to unit variance?
If \code{NULL} (default), automatically determined based on predictor types.}

\item{k}{Integer. Optional. If provided, cuts tree to k clusters.}

\item{h}{Numeric. Optional. If provided, cuts tree at height h.}

\item{...}{Additional arguments passed to \code{\link[stats:hclust]{stats::hclust()}}}
}
\value{
An object of class \code{c("stat_hclust", "momstats")} containing:
\itemize{
\item \code{data}: Original tibble (unchanged)
\item \code{model}: The \code{\link[stats:hclust]{stats::hclust()}} object
\item \code{dist_matrix}: Distance matrix used for clustering
\item \code{method}: Agglomeration method
\item \code{dist_method}: Distance metric used
\item \code{call}: The function call
\item \code{formula}: Formula used (if any)
\item \code{predictor_cols}: All predictor column names
\item \code{center}: Logical, was centering applied
\item \code{scale}: Logical, was scaling applied
\item \code{k}: Number of clusters (if tree was cut)
\item \code{h}: Height threshold (if tree was cut by height)
\item \code{clusters}: Cluster assignments (if tree was cut)
}
}
\description{
Perform hierarchical clustering on coefficient data.
}
\details{
\code{stat_hclust()} provides hierarchical clustering for morphometric data with
proper handling of coefficient columns and optional covariates.
\subsection{Agglomeration methods}{
\itemize{
\item \code{"ward.D2"} (default): Ward's minimum variance method - typically best for
morphometric data as it minimizes within-cluster variance
\item \code{"complete"}: Maximum distance between clusters
\item \code{"average"}: UPGMA - average distance between clusters
\item \code{"single"}: Minimum distance (tends to chain)
}
}

\subsection{Distance metrics}{
\itemize{
\item \code{"euclidean"} (default): Standard L2 distance
\item \code{"manhattan"}: L1 distance, more robust to outliers
\item \code{"maximum"}: Chebyshev distance
}
}

\subsection{Cutting the tree}{

The tree can be cut during creation or later:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Cut during creation
hc <- stat_hclust(data, k = 4)

# Cut later via collect
hc <- stat_hclust(data)
data_clustered <- collect(hc, k = 4)
}\if{html}{\out{</div>}}
}

\subsection{Getting results}{

Use \code{\link[=collect]{collect()}} to add cluster assignments:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{hc <- boteft \%>\% stat_hclust()
boteft_clustered <- collect(hc, k = 4)
}\if{html}{\out{</div>}}

Use \code{\link[=transduce]{transduce()}} to reconstruct shapes:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Cluster centers (if tree was cut)
centers <- transduce(hc, tibble(cluster = 1:4))

# Any node in the tree
node_shapes <- transduce(hc, tibble(node = c(45, 50, 55)))
}\if{html}{\out{</div>}}
}
}
\examples{
\dontrun{
# Basic hierarchical clustering
hc1 <- boteft \%>\% stat_hclust()

# With specific method
hc2 <- boteft \%>\% stat_hclust(method = "average")

# Cut tree during creation
hc3 <- boteft \%>\% stat_hclust(k = 4)

# Different distance
hc4 <- boteft \%>\% stat_hclust(dist_method = "manhattan")

# Add cluster assignments
boteft_clustered <- collect(hc1, k = 4)

# Get cluster center shapes
centers <- transduce(hc3, tibble(cluster = 1:4))

# Get shapes at internal nodes
nodes <- transduce(hc1, tibble(node = c(45, 50)))

# Plot (requires ape package)
plot(hc1)  # Unrooted phylogram (default)
plot(hc1, color = type)  # Color by grouping
plot(hc1, type = "dendrogram")  # Classic dendrogram
}

}
\seealso{
\code{\link[stats:hclust]{stats::hclust()}}, \code{\link[stats:dist]{stats::dist()}}, \code{\link[=collect.stat_hclust]{collect.stat_hclust()}},
\code{\link[=plot.stat_hclust]{plot.stat_hclust()}}, \code{\link[=transduce.stat_hclust]{transduce.stat_hclust()}}
}
